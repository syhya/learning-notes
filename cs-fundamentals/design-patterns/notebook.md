# 面向对象设计 SOLID 原则

## SOLID 原则

### 开放封闭原则
- **定义**：对扩展开放，对修改关闭。

### 里氏替换原则
- **定义**：所有引用父类的地方必须能使用其子类的对象。

### 依赖倒置原则
- **定义**：高层模块不应该依赖底层模块，两者都应该依赖其抽象。抽象不应该依赖细节，细节应该依赖抽象。针对接口编程。

### 接口隔离原则
- **定义**：使用多个专门的接口，而不使用单一的总接口。

### 单一职责原则
- **定义**：一个类只负责一项职责。

## 设计模式分类

### 创建型模式（5种）
- 工厂方法模式
- 抽象工厂模式
- 创建者模式
- 原型模式
- 单例模式

### 结构型模式（7种）
- 适配器模式
- 桥模式
- 组合模式
- 装饰模式
- 外观模式
- 享元模式
- 代理模式

### 行为型模式（11种）
- 解释器模式
- 责任链模式
- 命令模式
- 迭代器模式
- 中介者模式
- 备忘录模式
- 观察者模式
- 状态模式
- 策略模式
- 访问者模式
- 模版方法模式

---

# 创建型模式

## 简单工厂模式

### 内容
- 不直接向客户端暴露对象创建的实现细节，而是通过一个工厂类来负责创建产品类的实例。用工厂类来调用产品类。

### 角色
- **工厂角色（Creator）**：`PaymentFactory`
- **抽象产品角色（Product）**：`Payment`
- **具体产品角色（Concrete Product）**：`Alipay`, `Wechatpay`, `use_huabei`

### 优点
1. 隐藏类对象创建的实现细节。
2. 客户端不需要修改代码。

### 缺点
1. 违反了单一职责原则，将创建逻辑集中到一个工厂类里。
2. 当添加新产品时，需要修改工厂类代码，违反了开闭原则。

## 工厂方法模式

### 内容
- 定义一个用于创建对象的接口（工厂接口），让子类决定实例化哪一个产品类。

### 角色
- **抽象工厂角色（Creator）**
- **具体工厂角色（Creator）**
- **抽象产品角色（Product）**
- **具体产品角色（Concrete Product）**

### 优点
1. 每个具体产品都对应一个具体工厂类，不需要修改工厂类代码。
2. 隐藏类对象创建的实现细节。

### 缺点
- 每增加一个具体产品类，就必须增加一个相应的具体工厂类。

## 抽象工厂模式

### 内容
- 定义一个工厂类接口，让工厂子类来创建一系列相关或者相互依赖的对象。
- **例**：生产一部手机，需要手机壳、CPU、操作系统三类对象进行组装，其中每类对象都有不同的种类。对于每个具体工厂，分别生产一部手机所需要的三个对象。

### 相比工厂方法模式
- 抽象工厂模式中的每个具体工厂都生产一套产品。

### 角色
- **抽象工厂角色（Creator）**
- **具体工厂角色（Creator）**
- **抽象产品角色（Product）**
- **具体产品角色（Concrete Product）**
- **客户端（Client）**

### 优点
1. 将客户端与类的具体实现相分离。
2. 每个工厂创建了一个完整的产品系列，使得易于交换产品系列。
3. 有利于产品的一致性（即产品之间的约束关系）。

### 缺点
- 难以支持新种类的（抽象）产品。

## 建造者模式

### 内容
- 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

### 角色
- **抽象建造者（Builder）**
- **具体建造者（Concrete Builder）**
- **指挥者（Director）**
- **产品（Product）**

### 区别
- **建造者模式**：一步步构造一个复杂对象（可以通过 Director 控制对象执行的顺序）。
- **抽象工厂模式**：创建多个系列产品的对象。

### 优点
1. 隐藏了一个产品的内容结构和装配过程。
2. 将构造代码与表示代码分开。
3. 可以对构造过程进行更精细的控制。

## 单例模式

### 内容
- 保证一个类只有一个实例，并提供一个访问它的全局访问点。

### 角色
- **单例（Singleton）**

### 优点
- 对唯一实例的受控访问。
- 单例相当于全局变量，但防止类命名空间被污染。

---

# 结构型模式

## 适配器模式

### 内容
- 将一个类的接口转换为客户端希望的另一个接口。适配器模式使得原本由于接口不兼容不能一起工作的那些类可以一起工作。

### 实现方式
- **类适配器**：使用多继承。
- **对象适配器**：使用组合。

### 角色
- **目标接口（Target）**
- **待适配的类（Adaptee）**
- **适配器（Adapter）**

### 使用场景
- 想使用一个已经存在的类，而它的接口不符合你的要求。

## 桥模式

### 内容
- 像桥一样将两个维度搭在一起。

### 详细定义
- 将一个事物的两个维度分离，使其都可以独立地变化。

### 角色
- **抽象（Abstraction）**
- **细化抽象（Refined Abstraction）**
- **实现者（Implementor）**
- **具体实现者（Concrete Implementor）**

## 组合模式

### 内容
- 将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

### 角色
- **抽象组件（Component）**
- **叶子组件（Leaf）**
- **复合组件（Composite）**
- **客户端（Client）**

### 适用场景
1. 表示对象的“部分-整体”层次结构（特别是结构是递归的）。
2. 希望用户忽略组合对象和单个对象的不同，统一地使用组合结构中的所有对象。

### 优点
1. 定义类包含基本对象和组合对象的层次结构。
2. 简化了客户端代码，即客户端可以一致地使用单个对象和组合对象。
3. 更容易增加新类型的组件。

## 外观模式

### 内容
- 为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，使得子系统更加容易使用。

### 角色
- **外观（Facade）**
- **子系统类（Subsystem Classes）**

### 优点
1. 减少了相互依赖。
2. 提高了灵活性。
3. 提高了安全性。

## 代理模式

### 内容
- 为其他对象提供一种代理以控制对这个对象的访问。

### 应用场景
- **远程代理**：为远程的对象提供代理。
- **虚代理**：根据需要创建大型对象。
- **保护代理**：控制对原始对象的访问，用于对象有不同访问权限时。

### 角色
- **抽象实体（Subject）**
- **实体（Real Subject）**
- **代理（Proxy）**

### 优点
- **远程代理**：可以隐藏对象位于远程地址空间的事实。
- **虚代理**：可以进行优化，例如根据需求创建对象。
- **保护代理**：允许在访问一个对象时进行一些附加的内部处理。

---

# 行为型模式

## 责任链模式

### 内容
- 使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止。

### 角色
- **抽象处理者（Handler）**
- **具体处理者（ConcreteHandler）**
- **客户端（Client）**

### 适用场景
1. 有多个对象可以处理一个请求，哪个对象处理由运行时决定。
2. 在不明确接受者的情况下，向多个对象中的一个提交请求。

### 优点
- 降低耦合度：一个对象无需知道是其他哪个对象处理其请求。

## 观察者模式（发布-订阅模式）

### 内容
- 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

### 角色
- **抽象主题（Subject）**
- **具体主题（ConcreteSubject）** - 发布者
- **抽象观察者（Observer）**
- **具体观察者（ConcreteObserver）** - 订阅者

### 适用场景
1. 当一个抽象模型有两方面，其中一个依赖于另一个方面，可以各自独立改变和复用。
2. 当一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变。
3. 当一个对象必须通知其他对象，而不能假定其他对象是谁，不希望这些对象是紧密耦合的。

### 优点
1. 目标和观察者之间的抽象耦合最小。
2. 支持广播通信。

## 策略模式

### 内容
- 定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

### 角色
- **抽象策略（Strategy）**
- **具体策略（ConcreteStrategy）**
- **上下文（Context）**

### 优点
- 定义一系列可重用的算法和行为。
- 消除了一些条件语句。
- 提供相同行为的不同实现。

### 缺点
- 客户端必须了解不同的策略。

## 模版方法模式

### 内容
- 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

### 角色
- **抽象类（AbstractClass）**：定义抽象的原子操作（钩子操作），实现一个模版方法作为算法的骨架。
- **具体类（ConcreteClass）**：实现原子操作。

### 使用场景
1. 一次性实现一个算法的不变的部分。
2. 各个子类中的公共行为应该被提取出来并集中到一个公共父类中以避免代码重复。
3. 控制子类扩展。

---
